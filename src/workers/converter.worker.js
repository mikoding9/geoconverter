/**
 * Web Worker for handling large file conversions off the main thread.
 * This prevents UI freezing during GDAL processing.
 */

let isInitialized = false;
let Module = null;

// Initialize WASM module when worker starts
const initialize = async () => {
  if (isInitialized) return;

  try {
    // Import the compiled WASM module directly
    // The cpp.js file is generated by the cpp.js build process and named 'cpp'
    // via the cppjs.config.js configuration
    const baseUrl = self.location.origin || '';

    importScripts(baseUrl + '/cpp.js');

    // initCppJs is exported as a global by the cpp.js module
    // Wait for the module to be ready
    Module = await self.initCppJs();
    isInitialized = true;
  } catch (error) {
    console.error('Failed to initialize WASM in worker:', error);
    throw error;
  }
};

self.onmessage = async function(e) {
  const {
    type,
    fileData,
    inputFormat,
    outputFormat,
    options,
    fileName
  } = e.data;

  try {
    // Ensure WASM is initialized
    if (!isInitialized) {
      await initialize();
    }

    if (type === 'convert') {
      // Create C++ vector from file data
      const inputArray = new Uint8Array(fileData);
      const inputVector = new Module.VectorUint8();

      for (let i = 0; i < inputArray.length; i++) {
        inputVector.push_back(inputArray[i]);
      }

      // Perform conversion with all options
      const outputVector = Module.Native.convertVector(
        inputVector,
        inputFormat,
        outputFormat,
        options.sourceCrs,
        options.targetCrs,
        options.layerName,
        options.geometryTypeFilter,
        options.skipFailures,
        options.makeValid,
        options.keepZ,
        options.whereClause,
        options.selectFields,
        options.simplifyTolerance,
        options.explodeCollections,
        options.preserveFid,
        options.geojsonPrecision,
        options.csvGeometryMode
      );

      if (!outputVector || outputVector.size() === 0) {
        inputVector.delete();
        if (outputVector) outputVector.delete();

        const lastError = typeof Module.Native.getLastError === 'function'
          ? Module.Native.getLastError()
          : '';

        throw new Error(lastError || 'Conversion failed - output is empty');
      }

      // Convert C++ vector back to Uint8Array
      const outputSize = outputVector.size();
      const outputArray = new Uint8Array(outputSize);
      for (let i = 0; i < outputSize; i++) {
        outputArray[i] = outputVector.get(i);
      }

      // Clean up C++ objects
      inputVector.delete();
      outputVector.delete();

      // Send result back to main thread (transfer ownership for efficiency)
      self.postMessage({
        success: true,
        data: outputArray.buffer,
        fileName
      }, [outputArray.buffer]);

    } else if (type === 'getVectorInfo') {
      // For preview functionality
      const inputArray = new Uint8Array(fileData);
      const inputVector = new Module.VectorUint8();

      for (let i = 0; i < inputArray.length; i++) {
        inputVector.push_back(inputArray[i]);
      }

      const info = Module.Native.getVectorInfo(
        inputVector,
        inputFormat,
        options.sourceCrs
      );

      inputVector.delete();

      self.postMessage({
        success: true,
        info,
        fileName
      });
    }

  } catch (error) {
    const nativeError = Module && typeof Module.Native.getLastError === 'function'
      ? Module.Native.getLastError()
      : '';

    self.postMessage({
      success: false,
      error: nativeError || error.message,
      fileName
    });
  }
};
